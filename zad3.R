library(ConsPlan)
library(vecsets)

read.sudoku <- function(filename) # Reads sudoku grid from file
{
  x <- as.matrix(read.table(filename))
  return (x)
}

cost <- function(X) # Calculates costs based on number of repetitions
                     # and number of zeros in matrix
{
  X <- matrix(X, ncol=sqrt(length(X))) # sann passes X as vector
  
  cost <- length(which(X==0)) # Add zeros to cost, so that they are replaced
  
  #Rows and columns
  cost <- cost + sum(apply(X, 1, duplicated) + apply(X, 2, duplicated))
  
  # 3x3 grids
  p <- sqrt(nrow(X))
  for(i in 1:p) {
    for(k in 1:p) {
      tmp <- c(X[(p*(i-1)+1):(p*i),(p*(k-1)+1):(p*k)]) # Copy the small grid
      cost <- cost + length(tmp[duplicated(tmp)]) # Add duplicate values
    }
  }
  
  return(cost)
}

make.next.state <- function(startgrid) # Use this function to create next.state objects
                                       # It keeps the sudoku starting elements
                                       # so that they don't get swapped
{
  matched <<- 0
  Grid <<- startgrid
  next.state <- function(X) # Next state is generated by swapping two random values
  {
    X <- matrix(X, ncol=sqrt(length(X))) # sann passes X as vector
    
    x1 <- sample(1:sqrt(length(X)),1) # Set first pair
    y1 <- sample(1:sqrt(length(X)),1)
    
    while(Grid[x1,y1] != 0) { # Repeat until found elements
                              # that are not fixed
      x1 <- sample(1:sqrt(length(X)),1)
      y1 <- sample(1:sqrt(length(X)),1)
    }
    
    x2 <- sample(1:sqrt(length(X)),1) # Set second pair
    y2 <- sample(1:sqrt(length(X)),1)
    
    while(Grid[x2,y2] != 0 || (x1==x2 && y1==y2)) { # Repeat until found
                                                    # different and not fixed pair
      x2 <- sample(1:sqrt(length(X)),1)
      y2 <- sample(1:sqrt(length(X)),1)
    }
    tmp <- X[x1,y1] # Swap values
    X[x1,y1] <- X[x2,y2]
    X[x2,y2] <- tmp
    
    return(c(X))
  }
  next.state2 <- function(X) # Next state is generated by swapping two random  values (from one row)
  {
    X <- matrix(X, ncol=sqrt(length(X))) # sann passes X as vector
    nr <- 1 # In how many rows perform swap
    
    if(cost(X)>=2 && cost(X)<=12) {
      x <- Grid # Start again
      return(c(X))
    }
    
    
    r <- sample(1:sqrt(length(X)),nr) # Choose random rows to perform swapping in them
    for(i in r) {
      y1 <- sample(1:sqrt(length(X)), 1) # Find value X[i,y1] that is not fixed
      while(Grid[i,y1]!=0) {
        y1 <- sample(1:sqrt(length(X)), 1)
      }
      y2 <- sample(1:sqrt(length(X)), 1)
      while(Grid[i,y2]!=0 || y1==y2) { # Find value X[i,y2] that is not fixed and y1!=y2
        y2 <- sample(1:sqrt(length(X)), 1)
      }
      tmp <- X[i,y1] # Swap these values
      X[i,y1] <- X[i,y2]
      X[i,y2] <- tmp
    }
    
    return(c(X))
  }
  
  next.state3 <- function(X) # Puts one of the possible values for given place
  {
    X <- matrix(X, ncol=sqrt(length(X))) # sann passes X as vector
    
    #X <- try.deduce(X) # Maybe it is possible to deduce whole grid already
    if(cost(X)==0) {
      return(c(X))
    }
    
    s <- which(X==0) # Get indexes of empty fields
    
    ind <- ceiling(runif(1, 1, length(s))) # Choose random index in s
    
    s.x <- if(s[ind] %% 9 == 0) 9 else (s[ind] %% 9) 
    s.y <- if(s[ind]/9 == s[ind]%/%9) (s[ind] %/% 9) else (s[ind] %/% 9)+1
    
    c <- get.possible(X, s.x, s.y) # Get all possible values for that field
    
    if(length(c)==0) { # Got stuck
      X <- Grid # Revert everything
      return (c(X))
    } 
    
    c <- sample(c,1) # Choose one randomly
    X <- c(X) # Flatten matrix
    X[s[ind]] <-c 
    
    return(X)
  }
  
  next.state4 <- function(X) # Next state is generated by putting value from pool into sudoku
  {
    pool <- rep(1:9, 9)
    pool <- vsetdiff(pool,Grid)
                 
    pool <- unique(pool) # Need only unique values as trying to fit in only one place
    
    s <- which(Grid == 0) # Get all 0 values
    
    s<-sample(s) # Shuffle s
    
    pool <- append(pool, X[s[1]]) # The replaced element is also valid for insterting
    pool <- sample(pool) # Shuffle pool
    
    X[s[1]] <- pool[1] # Assign new value

    return(X)
  }
  next.state5 <- function(X)
  {
    
  }
  
  return (next.state3)
}

solve.sudoku <- function(filename, it, temp, tmax,fill=TRUE, deduce=3)
{
  x <- matrix(as.numeric(read.sudoku(filename)), ncol=9)
  f <- make.next.state(x)

  x <- try.deduce(x,deduce)
  Grid <<- x
  if(cost(x)==0) {
    return (x)
  }
  
  if(fill) { # fill grid with random values at start
             # (but allowing to solve sudoku with only swapping)
    
    for(l in 1:nrow(x)) { 
    s <- vsetdiff(c(1:9),x[l,])   # Take out elements that are already
                             # in this row
    s <- sample(s) # Shuffle them
    
    k<-1 # Indexer for s
    for(i in 1:ncol(x)) {
      if(x[l,i]==0) { # Put random value in field if it's free
        x[l,i]<-as.numeric(s[k]) 
          k<-k+1
        }
      }
    }
  }
  return (sann(x, cost, f, maxit=it, REPORT=250, temp=temp, tmax=tmax))
}


try.deduce <- function(X, it=10) 
{
  n <- 0
  changed <- TRUE
  while(changed && n < it) {
    changed <- FALSE
    
    p <- sqrt(nrow(X))
    for(i in 1:p) { # For each grid
      for(k in 1:p) {
        tmp <- X[(p*(i-1)+1):(p*i),(p*(k-1)+1):(p*k)] # Copy the small grid
        q <- matrix(0, ncol=9, nrow=9) # For storing possible values for each element of the grid
        for(j in 1:nrow(tmp)) { # For each value in grid
          for(l in 1:ncol(tmp)) {
            if(X[3*(i-1)+j,3*(k-1)+l]==0) {
              t <- get.possible(X,3*(i-1)+j,3*(k-1)+l)
              if(length(t)>0) {
                q[3*(j-1)+l,1:length(t)] <- t 
              }
            }
          }
        }
        # Find value which is possible for only one field
        for(j in 1:9) {
          if(length(q[q==j])==1) {
            ind = which(q==j)
            val <- q[q==j] # Value to put in X
              y.ind <- if(ind/9 == ind%/%9) (ind %/% 9) else (ind %/% 9)+1
              x.ind <- if(ind %% 9 == 0) 9 else (ind %% 9)
              
              # x.ind is index of q, q's 
              qx.ind <- if(x.ind/3 == x.ind%/%3) (x.ind %/% 3) else (x.ind %/% 3)+1
              qy.ind <- if(x.ind %% 3 == 0) 3 else (x.ind %% 3)
              
              X[3*(i-1)+qx.ind,3*(k-1)+qy.ind] <- val # Assign deduced value
              
              changed=TRUE
              
          }
        }
        
      }
    }
    
    #Previous sol...
    
    n <- n+1
  }
  return(X)
}

get.possible <- function(x, i, j)
{
  s <- x[i,]
  s <- append(s,x[,j])
  s <- append(s, get.neighbours(x,i,j))
  s <- s[s!=0]
  
  s <- unique(s)
  s <- vsetdiff(1:9, s)
  
  return(s)
}

get.neighbours <- function(x, i, j)
{
  r <- c(0)
  if(i <= 3) {
    if(j <= 3) {
      r <- c(x[1:3,1:3])
    }
    else if(j<=6) {
      r <- c(x[1:3,4:6])
    }
    else {
      r <- c(x[1:3,7:9])
    }
  }
  else if (i <= 6) {
    if(j <= 3) {
      r <- c(x[4:6,1:3])
    }
    else if(j<=6) {
      r <- c(x[4:6,4:6])
    }
    else {
      r <- c(x[4:6,7:9])
    }
  }
  else {
    if(j <= 3) {
      r <- c(x[7:9,1:3])
    }
    else if(j<=6) {
      r <- c(x[7:9,4:6])
    }
    else {
      r <- c(x[7:9,7:9])
    }
  }
  return(r)
}